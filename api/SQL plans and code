----------- Tuning database -------------------

DROP TABLE IF EXISTS `weekly_tuning`;
CREATE TABLE `weekly_tuning` (
  `ID` int(11) NOT NULL,
  `net` varchar(8) DEFAULT NULL,
  `date` datetime DEFAULT NULL,
  `demo` varchar(20) DEFAULT NULL,
  `stream` varchar(8) DEFAULT NULL,
  `reach_aa` decimal(7,2) DEFAULT NULL,
  `reach_imp` int(15) DEFAULT NULL,
  `freq` decimal(7,2) DEFAULT NULL,
  `mins_viewed` decimal(7,2) DEFAULT NULL,
  `duration` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

ALTER TABLE `weekly_tuning`
 ADD UNIQUE KEY `unique_index` (`net`,`date`,`stream`,`demo`), ADD KEY `ID` (`ID`);


 DROP TABLE IF EXISTS `ag_weeklytuning`;
 CREATE TABLE `ag_weeklytuning` (
   `ID` int(11) NOT NULL,
   `net` varchar(8) DEFAULT NULL,
   `stream` varchar(8) DEFAULT NULL,
   `period` varchar(20) DEFAULT NULL,
   `demo` varchar(20) DEFAULT NULL,
   `reach_aa` decimal(7,2) DEFAULT NULL,
   `reach_imp` int(15) DEFAULT NULL,
   `freq` decimal(7,2) DEFAULT NULL,
   `mins_viewed` decimal(7,2) DEFAULT NULL,
   `duration` int(11) DEFAULT NULL
 ) ENGINE=InnoDB DEFAULT CHARSET=latin1;

 ALTER TABLE `ag_weeklytuning`
  ADD UNIQUE KEY `unique_index` (`net`,`period`,`stream`,`demo`), ADD KEY `ID` (`ID`);

  REPLACE INTO ag_weeklytuning (net, stream, demo, reach_aa, reach_imp, freq, mins_viewed, duration, period)
    SELECT net, stream, demo, avg(reach_aa) AS reach_aa, avg(reach_imp) AS reach_imp, avg(freq) AS freq, avg(mins_viewed) AS mins_viewed, sum(duration) AS duration, qtrs.label as period FROM weekly_tuning LEFT JOIN bcast_quarters as qtrs ON (date>=qtrs.start and date<=qtrs.stop) GROUP BY net, demo, stream, period;









- getweeks (ALREADY EXISTS!!!!)
- getMonths (needs to return a # of weeks count!!!)
- getYears (needs to return a # of weeks count!!!)
- getPROneSheet
  - combines all dbs: telecasts, dayparts, tuning



Time-Based API needs:
- by year, qtr, month, week, day
- by network
- for these demos
- time-series or straight up avg


reqTimeSeriesByNet ()
  - nets = []
  - start
  - stop? (optional)
  - interval (wkly/monthly/qtrly/yrly)
  - daypart (prime or total day)
  - demos = []
  - type = "ratings"

reqYAGORatingsComps
 - nets = []
 - current = wk/month/qtr/yr?
 - yago = wk/month/qtr/yr?
 -


//get a ranker of Prime??? ratings?
SELECT net, rating_val, duration FROM ag_dayparts WHERE (type="aa" AND stream="l3d" AND demo="p25_54" AND period="1Q16") ORDER BY rating_val DESC;

//get a qtrly premiere average
SELECT net, rating_val, (duration/60) as duration FROM ag_premavgs WHERE (type="aa" AND stream="lsd" AND demo="p25_54" AND period="1Q14") ORDER BY rating_val DESC;

-------- AG_DAYPARTS --------------------

DROP TABLE IF EXISTS `daypart_ratings`;
CREATE TABLE daypart_ratings
(
`ID` int(11) NOT NULL,
  `net` varchar(8) DEFAULT NULL,
  `date` datetime DEFAULT NULL,
  `daypart` varchar(20) DEFAULT NULL,
  `type` varchar(8) DEFAULT NULL,
  `stream` varchar(8) DEFAULT NULL,
  `demo` varchar(20) DEFAULT NULL,
  `rating_val` decimal(7,2) DEFAULT NULL,
  `duration` int(11) DEFAULT NULL
) ENGINE=InnoDB  DEFAULT CHARSET=latin1 AUTO_INCREMENT=9 ;

ALTER TABLE `daypart_ratings` ADD UNIQUE `unique_index`(`net`, `date`, `daypart`, `type`, `stream`, `demo`);



  REPLACE INTO ag_dayparts (net, type, stream, demo, daypart, rating_val, duration, period)
    SELECT net, type, stream, demo, daypart, avg(rating_val) AS rating_val, sum(duration) AS duration, qtrs.label as period FROM timebased_data LEFT JOIN bcast_quarters as qtrs ON (date>=qtrs.start and date<=qtrs.stop) GROUP BY net, type, demo, stream, period, daypart;


    DROP TABLE IF EXISTS `ag_dayparts`;
    CREATE TABLE `ag_dayparts` (
      `ID` int(11) NOT NULL,
      `net` varchar(8) DEFAULT NULL,
      `daypart` varchar(20) DEFAULT NULL,
      `period` varchar(20) DEFAULT NULL,
      `type` varchar(8) DEFAULT NULL,
      `stream` varchar(8) DEFAULT NULL,
      `demo` varchar(20) DEFAULT NULL,
      `rating_val` decimal(7,2) DEFAULT NULL,
      `duration` int(11) DEFAULT NULL
    ) ENGINE=InnoDB DEFAULT CHARSET=latin1;

    ALTER TABLE `ag_dayparts`
     ADD UNIQUE KEY `unique_index` (`net`,`daypart`,`period`,`type`,`stream`,`demo`), ADD KEY `ID` (`ID`);


-------- AG_PREMAVGS --------------------
DROP TABLE IF EXISTS `ag_premavgs`;
CREATE TABLE `ag_premavgs` (
  `ID` int(11) NOT NULL,
  `net` varchar(8) DEFAULT NULL,
  `period` varchar(20) DEFAULT NULL,
  `type` varchar(8) DEFAULT NULL,
  `stream` varchar(8) DEFAULT NULL,
  `demo` varchar(20) DEFAULT NULL,
  `rating_val` decimal(7,2) DEFAULT NULL,
  `duration` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
ALTER TABLE `ag_premavgs`
 ADD UNIQUE KEY `unique_index` (`net`,`period`,`type`,`stream`,`demo`), ADD KEY `ID` (`ID`);

 REPLACE INTO ag_premavgs (net, period, type, stream, demo, rating_val, duration)
 SELECT tr.net as net, qtrs.label as period, tr.rating_type as type, tr.data_stream as stream, tr.demo as demo, SUM( tr.rating_val * ti.duration ) / SUM( ti.duration ) AS rating_val, SUM(ti.duration) as duration
     FROM telecast_info ti
     LEFT JOIN telecast_ratings tr ON tr.net = ti.net AND tr.date_time =ti.date_time
     LEFT JOIN bcast_quarters as qtrs ON (tr.date_time>=qtrs.start and tr.date_time<=qtrs.stop)
     WHERE (ti.telecast_code NOT LIKE '%R%')
     GROUP BY net, type, demo, stream, period;




-------------------------------------------
CREATE TABLE `bcast_years` (
`ID` int(11) NOT NULL,
  `label` varchar(4) DEFAULT NULL,
  `start` datetime DEFAULT NULL,
  `stop` datetime DEFAULT NULL
) ENGINE=InnoDB  DEFAULT CHARSET=latin1 AUTO_INCREMENT=17 ;


INSERT INTO `bcast_years` (`ID`, `label`, `start`, `stop`) VALUES
(0, '2012', '2011-12-26 00:00:00', '2012-12-30 23:59:59'),
(1, '2013', '2012-12-31 00:00:00', '2013-12-29 23:59:59'),
(2, '2014', '2013-12-30 00:00:00', '2014-12-28 23:59:59'),
(3, '2015', '2014-12-29 00:00:00', '2015-12-27 23:59:59'),
(4, '2016', '2015-12-28 00:00:00', '2016-12-25 23:59:59'),
(5, '2017', '2016-12-26 00:00:00', '2017-12-30 23:59:59');

ALTER TABLE `bcast_years`
 ADD PRIMARY KEY (`ID`);
ALTER TABLE `bcast_years`
MODIFY `ID` int(11) NOT NULL AUTO_INCREMENT,AUTO_INCREMENT=17;


ALTER TABLE bcast_years ADD year int;

----------------------------------------------------------
----- NECESSARY UPDATES TO TABLE -------------------------
ALTER TABLE ag_dayparts MODIFY COLUMN ID INT auto_increment;
ALTER TABLE ag_premavgs MODIFY COLUMN ID INT auto_increment;

ALTER TABLE daypart_ratings DROP COLUMN ID;
ALTER TABLE daypart_ratings ADD id INT NOT NULL AUTO_INCREMENT PRIMARY KEY;

ALTER TABLE weekly_tuning DROP COLUMN ID;
ALTER TABLE weekly_tuning ADD id INT NOT NULL AUTO_INCREMENT PRIMARY KEY;

ALTER TABLE bcast_quarters ADD year int;
ALTER TABLE bcast_quarters ADD qtr int;



//CodeIgniter-Version Upload Scripts
INSERT INTO cleanlist_series (dirty_name) SELECT DISTINCT telecast_name FROM telecast_info;";
UPDATE cleanlist_series SET clean_name=dirty_name WHERE clean_name IS NULL;
INSERT INTO netlist (net) SELECT DISTINCT net FROM telecast_info;

UPDATE daypart_ratings SET stream="l3d";
UPDATE daypart_ratings SET daypart="Prime";




This works (Find last day in daypart_ratings, figure out the quarter and the YAGO QTD equivalent):
  SELECT
    @num:=DATEDIFF(maxtable.maxdate, bq.start),
    label, bq.year, bq.qtr, bq.start, maxtable.maxdate, DATEDIFF(maxtable.maxdate, bq.start) AS daysin, yagot.yagostart, yagot.yagostop
  FROM bcast_quarters bq
    INNER JOIN (select max(date) as maxdate
    FROM daypart_ratings) maxtable
      ON (maxtable.maxdate>=bq.start AND maxtable.maxdate<=bq.stop)
    INNER JOIN (SELECT year+1 AS yagoyear, start AS yagostart, DATE_ADD(start, INTERVAL @num DAY) AS yagostop, qtr
    FROM bcast_quarters) yagot
      ON (bq.year =yagot.yagoyear AND bq.qtr=yagot.qtr);




GET THE QTD and YAGO-QTD AVG BY NETWORK

SELECT curryr.net, avg(curryr.rating_val) as cur_rating, SUM(curryr.duration) as curr_dur, bq.year, bq.qtr, yago_yr.yago_rating, yago_yr.yago_dur
FROM daypart_ratings curryr
INNER JOIN (SELECT net, date, avg(rating_val) as yago_rating, sum(duration) as yago_dur FROM daypart_ratings WHERE type='imp' AND stream='l3d' AND demo='p25_54' AND (net = 'APL' OR net = 'DISC') AND (date >= '2015-6-29' AND date <= '2015-9-20') GROUP BY net) yago_yr
  ON (curryr.net=yago_yr.net)
INNER JOIN (SELECT label, start, stop, year, qtr
FROM bcast_quarters) bq
  ON (curryr.date>=bq.start AND curryr.date<=bq.stop)
WHERE ((curryr.net = 'APL' OR curryr.net = 'DISC') AND curryr.type='imp' AND curryr.stream='l3d' AND curryr.demo='p25_54' AND
  ((curryr.date >= '2016-6-27' AND curryr.date <= '2016-9-18')))
GROUP BY curryr.net, bq.label;


SELECT curryr.net, avg(curryr.rating_val) as cur_rating, SUM(curryr.duration) as curr_dur, bq.year, bq.qtr, yago_yr.yago_rating, yago_yr.yago_dur
FROM daypart_ratings curryr
  INNER JOIN (SELECT net, date, avg(rating_val) as yago_rating, sum(duration) as yago_dur
FROM daypart_ratings
  WHERE type='imp' AND stream='l3d' AND demo='p25_54' AND (net = "APL" OR net = "DISC" ) AND (date >= '2014-6-29' AND date <= '2014-9-20') GROUP BY net) yago_yr
  ON (curryr.net=yago_yr.net)
  INNER JOIN (SELECT label, start, stop, year, qtr
FROM bcast_quarters) bq
  ON (curryr.date>=bq.start AND curryr.date<=bq.stop) WHERE ((net = "APL" OR net = "DISC" ) AND curryr.type='imp' AND curryr.stream='l3d' AND curryr.demo='p25_54' AND ((curryr.date >= '2015-6-29' AND curryr.date <= '2015-9-20')))
GROUP BY curryr.net, bq.label;










------ THIS WORKS ------
should one api return a single stack of data that needs to be split? no


SELECT curryr.net, curryr.date, avg(curryr.rating_val) as cur_rating, SUM(curryr.duration) as curr_dur, 1+DATEDIFF(curryr.date, bq.start) DIV 7 as wknum, bq.year, bq.start
FROM daypart_ratings curryr
INNER JOIN (SELECT start, stop, year FROM bcast_years) bq
ON (curryr.date>=bq.start AND curryr.date<=bq.stop)
WHERE curryr.net="APL" and curryr.type="imp" and curryr.demo="p25_54"
GROUP BY curryr.net, wknum, bq.year
ORDER BY bq.year, wknum;



SELECT * FROM (SELECT curryr.net, curryr.date, avg(curryr.rating_val) as cur_rating, SUM(curryr.duration) as curr_dur, 1+DATEDIFF(curryr.date, bq.start) DIV 7 as wknum, bq.year, bq.start
FROM daypart_ratings curryr
INNER JOIN (SELECT start, stop, year FROM bcast_years) bq
ON (curryr.date>=bq.start AND curryr.date<=bq.stop)
WHERE curryr.net="APL" and curryr.type="imp" and curryr.demo="p25_54"
GROUP BY curryr.net, wknum, bq.year
ORDER BY bq.year, wknum) as currwkly;



SELECT * FROM (SELECT curryr.net, curryr.date, avg(curryr.rating_val) as cur_rating, SUM(curryr.duration) as curr_dur, 1+DATEDIFF(curryr.date, bq.start) DIV 7 as wknum, bq.year, bq.start
FROM daypart_ratings curryr
INNER JOIN (SELECT start, stop, year FROM bcast_years) bq
ON (curryr.date>=bq.start AND curryr.date<=bq.stop)
WHERE curryr.net="APL" and curryr.type="imp" and curryr.demo="p25_54"
GROUP BY curryr.net, wknum, bq.year
ORDER BY bq.year, wknum) as currwkly;
